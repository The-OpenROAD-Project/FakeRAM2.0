#!/usr/bin/env python3

import math
from exporter import Exporter


class LefExporter(Exporter):
    """
    Base class for LEF exporter

    Note that memory-type-specific methods are defined in their respective
    classes (e.g. look at single_port_sram_lef_exporter)
    """

    def __init__(self, memory):
        """Initializer"""
        Exporter.__init__(self, memory)
        # In rect_pin_mode, we try and avoid EOL spacing issues by:
        #   1) making the pins rectangular in the X direction:
        #          width: min_pin_width * 1.5
        #          height: 1.5 * min_pin_width
        #   2) reducing the width of the power/ground straps by one x_offset
        #      on the left side where the pins are
        self._rect_pin_mode = (
            memory.get_physical_data().get_pin_pitch()
            == memory.get_process_data().get_pin_pitch_um()
        )

    def export(self, out_fh):
        """Exports LEF file to output stream"""

        # Memory parameters
        mem = self.get_memory()
        name = mem.get_name()
        physical = mem.get_physical_data()
        w = physical.get_width()
        h = physical.get_height()
        pin_pitch = physical.get_pin_pitch()
        group_pitch = physical.get_group_pitch()

        # Process parameters
        process = mem.get_process_data()
        min_pin_width = process.get_pin_width_um()
        min_pin_pitch = process.get_pin_pitch_um()
        metal_prefix = process.get_metal_prefix()
        metal_layer = process.get_metal_layer()
        x_offset = process.get_x_offset()
        y_offset = process.get_y_offset()

        self.create_header(
            out_fh,
            name,
            w,
            h,
            self._memory.get_width(),
            self._memory.get_depth(),
            mem.num_banks,
        )
        self.create_signal_pins(out_fh, pin_pitch, group_pitch)
        self.create_pg_straps(
            out_fh, min_pin_width, min_pin_pitch, x_offset, y_offset, w, h, metal_layer
        )
        self.create_obs(out_fh, metal_layer, metal_prefix, w, h)
        self.write_footer(out_fh, name)

    def create_header(self, fid, name, w, h, bits, depth, banks):
        """LEF header"""

        fid.write("# Generated by FakeRAM 2.0\n")
        fid.write("VERSION 5.7 ;\n")
        fid.write('BUSBITCHARS "[]" ;\n')
        fid.write("PROPERTYDEFINITIONS\n")
        fid.write("  MACRO width INTEGER ;\n")
        fid.write("  MACRO depth INTEGER ;\n")
        fid.write("  MACRO banks INTEGER ;\n")
        fid.write("END PROPERTYDEFINITIONS\n")
        fid.write("MACRO %s\n" % (name))
        fid.write(f"  PROPERTY width {bits} ;\n")
        fid.write(f"  PROPERTY depth {depth} ;\n")
        fid.write(f"  PROPERTY banks {banks} ;\n")
        fid.write("  FOREIGN %s 0 0 ;\n" % (name))
        fid.write("  SYMMETRY X Y R90 ;\n")
        fid.write("  SIZE %.3f BY %.3f ;\n" % (w, h))
        fid.write("  CLASS BLOCK ;\n")

    def add_pin(self, fid, pin_name, is_input, y, pitch):
        """
        Helper function that adds a signal pin
        y_step = add_pin( fid, mem, 'w_mask_in[%d]'%i, True, y_step, pin_pitch )
        """
        mem = self.get_memory()
        process = mem.get_process_data()
        layer = process.get_metal_layer()
        pw = process.get_pin_width_um()
        hpw = process.get_pin_width_um() / 2.0
        # half pin width

        fid.write("  PIN %s\n" % pin_name)
        fid.write("    DIRECTION %s ;\n" % ("INPUT" if is_input else "OUTPUT"))
        fid.write("    USE SIGNAL ;\n")
        fid.write("    SHAPE ABUTMENT ;\n")
        fid.write("    PORT\n")
        fid.write("      LAYER %s ;\n" % layer)
        if self._rect_pin_mode:
            # make pins a little longer in the X direction
            fid.write(
                "      RECT %.3f %.3f %.3f %.3f ;\n" % (0, y - hpw, pw + hpw, y + hpw)
            )
        else:
            fid.write("      RECT %.3f %.3f %.3f %.3f ;\n" % (0, y - hpw, pw, y + hpw))
        fid.write("    END\n")
        fid.write("  END %s\n" % pin_name)

        return y + pitch

    def create_obs(self, fid, metal_layer, metal_prefix, w, h):
        """Create obstructions"""

        fid.write("  OBS\n")
        # full rect
        pin_layer_number = metal_layer.replace(metal_prefix, "", 1)
        for x in range(int(pin_layer_number)):
            dummy = x + 1
            fid.write("    LAYER %s%d ;\n" % (metal_prefix, dummy))
            fid.write("    RECT 0 0 %.3f %.3f ;\n" % (w, h))
        fid.write("  END\n")

    def create_pg_pin(
        self,
        fid,
        pin_name,
        pin_use,
        metal_layer,
        w,
        h,
        y_step,
        x_offset,
        y_offset,
        supply_pin_half_width,
        supply_pin_pitch,
    ):
        """Writes a power/ground pin"""

        fid.write("  PIN %s\n" % pin_name)
        fid.write("    DIRECTION INOUT ;\n")
        fid.write("    USE %s ;\n" % pin_use)
        fid.write("    PORT\n")
        fid.write("      LAYER %s ;\n" % metal_layer)
        self.create_pg_shapes(
            fid,
            w,
            h,
            y_step,
            x_offset,
            y_offset,
            supply_pin_half_width,
            supply_pin_pitch,
        )
        fid.write("    END\n")
        fid.write("  END %s\n" % pin_name)

    def create_pg_shapes(
        self,
        fid,
        w,
        h,
        y_step,
        x_offset,
        y_offset,
        supply_pin_half_width,
        supply_pin_pitch,
    ):
        """Creates power/ground shapes"""

        # if in rect_pin_mode we start the pin two offsets in to avoid
        # spacing issues with the signal pin
        mod_x_offset = x_offset * (self._rect_pin_mode + 1)
        while y_step <= h - y_offset:
            fid.write(
                "      RECT %.3f %.3f %.3f %.3f ;\n"
                % (
                    mod_x_offset,
                    y_step - supply_pin_half_width,
                    w - mod_x_offset,
                    y_step + supply_pin_half_width,
                )
            )
            y_step += (
                supply_pin_pitch * 2
            )  # this *2 is important because we want alternate VDD and VSS pins

    def create_pg_straps(
        self, fid, min_pin_width, min_pin_pitch, x_offset, y_offset, w, h, metal_layer
    ):
        """Create power/ground straps"""

        supply_pin_width = min_pin_width * 4
        supply_pin_half_width = supply_pin_width / 2
        supply_pin_pitch = min_pin_pitch * 8
        # supply_pin_layer = '%s' % metal_layer

        ## Create supply pins  : How are we ensuring that supply pins don't overlap
        ## with the signal pins? Is it by giving x_offset as the base x coordinate ?
        y_step = y_offset
        self.create_pg_pin(
            fid,
            "VSS",
            "GROUND",
            metal_layer,
            w,
            h,
            y_step,
            x_offset,
            y_offset,
            supply_pin_half_width,
            supply_pin_pitch,
        )

        y_step = y_offset + supply_pin_pitch
        self.create_pg_pin(
            fid,
            "VDD",
            "POWER",
            metal_layer,
            w,
            h,
            y_step,
            x_offset,
            y_offset,
            supply_pin_half_width,
            supply_pin_pitch,
        )

    def write_signal_bus(self, fid, name, num_pins, is_input, y_step, pin_pitch):
        """Writes the individual pins for a signal bus"""

        name_format = f"{name}[%d]"
        for i in range(int(num_pins)):
            y_step = self.add_pin(fid, name_format % i, is_input, y_step, pin_pitch)
        return y_step

    def write_footer(self, fid, name):
        """LEF footer"""
        fid.write("END %s\n" % name)
        fid.write("\n")
        fid.write("END LIBRARY\n")

    def create_signals(self, fid, suffix, y_step, pin_pitch, group_pitch):
        """Writes rw signal bundle, comprised of dout, din, addr busses"""

        bits = self.get_memory().get_width()
        y_step = self.write_signal_bus(
            fid, f"dout_{suffix}", bits, False, y_step, pin_pitch
        )
        y_step += group_pitch
        y_step = self.write_signal_bus(
            fid, f"din_{suffix}", bits, False, y_step, pin_pitch
        )
        y_step += group_pitch
        y_step = self.write_signal_bus(
            fid,
            f"addr_{suffix}",
            self._memory.get_addr_width(),
            True,
            y_step,
            pin_pitch,
        )
        y_step += group_pitch
        return y_step

    def create_signal_pins(self, fid, pin_pitch, group_pitch):
        """LEF SIGNAL PINS"""

        mem = self.get_memory()
        y_step = mem.get_process_data().y_step
        for i in range(0, mem.get_num_rw_ports()):
            suffix = chr(ord("a") + i)
            y_step = self.create_signals(fid, suffix, y_step, pin_pitch, group_pitch)
        for i in range(0, mem.get_num_rw_ports()):
            suffix = chr(ord("a") + i)
            y_step = self.add_pin(fid, f"we_{suffix}", True, y_step, pin_pitch)
        y_step = self.add_pin(fid, "clk", True, y_step, pin_pitch)
