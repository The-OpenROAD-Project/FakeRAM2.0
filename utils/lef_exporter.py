#!/usr/bin/env python3

import math
from exporter import Exporter


class LefExporter(Exporter):
    """
    Base class for LEF exporter

    Note that memory-type-specific methods are defined in their respective
    classes (e.g. look at single_port_sram_lef_exporter)
    """

    def __init__(self, memory):
        """Initializer"""
        Exporter.__init__(self, memory)
        # In rect_pin_mode, we try and avoid EOL spacing issues by:
        #   1) making the pins rectangular in the X direction:
        #          width: min_pin_width * 1.5
        #          height: 1.5 * min_pin_width
        #   2) reducing the width of the power/ground straps by one x_offset
        #      on the left side where the pins are
        self._rect_pin_mode = (
            memory.get_physical_data().get_pin_pitch()
            == memory.get_process_data().get_pin_pitch_um()
        )

    def export(self, out_fh):
        """Exports LEF file to output stream"""

        # Memory parameters
        mem = self.get_memory()
        name = mem.get_name()
        physical = mem.get_physical_data()
        w = physical.get_width()
        h = physical.get_height()
        pin_pitch = physical.get_pin_pitch()
        group_pitch = physical.get_group_pitch()

        # Process parameters
        process = mem.get_process_data()
        min_pin_width = process.get_pin_width_um()
        min_pin_pitch = process.get_pin_pitch_um()
        metal_prefix = process.get_metal_prefix()
        metal_layer = process.get_metal_layer()
        x_offset = process.get_x_offset()
        y_offset = process.get_y_offset()

        self.write_header(
            out_fh,
            name,
            w,
            h,
            self._memory.get_width(),
            self._memory.get_depth(),
            mem.num_banks,
        )
        self.write_signal_pins(out_fh)
        self.write_pg_straps(out_fh)
        self.write_obs(out_fh)
        self.write_footer(out_fh, name)

    def write_header(self, fid, name, w, h, bits, depth, banks):
        """LEF header"""

        fid.write("# Generated by FakeRAM 2.0\n")
        fid.write("VERSION 5.7 ;\n")
        fid.write('BUSBITCHARS "[]" ;\n')
        fid.write("PROPERTYDEFINITIONS\n")
        fid.write("  MACRO width INTEGER ;\n")
        fid.write("  MACRO depth INTEGER ;\n")
        fid.write("  MACRO banks INTEGER ;\n")
        fid.write("END PROPERTYDEFINITIONS\n")
        fid.write("MACRO %s\n" % (name))
        fid.write(f"  PROPERTY width {bits} ;\n")
        fid.write(f"  PROPERTY depth {depth} ;\n")
        fid.write(f"  PROPERTY banks {banks} ;\n")
        fid.write("  FOREIGN %s 0 0 ;\n" % (name))
        fid.write("  SYMMETRY X Y R90 ;\n")
        fid.write("  SIZE %.3f BY %.3f ;\n" % (w, h))
        fid.write("  CLASS BLOCK ;\n")

    def write_pin(self, fid, port, write_abutment=True):
        """
        Writes a port/pin
        """

        pin_name = port.get_name()
        fid.write(f"  PIN {pin_name}\n")
        fid.write(f"    DIRECTION {port.get_direction().get_lef_name()} ;\n")
        fid.write(f"    USE {port.get_use()} ;\n")
        if write_abutment:
            fid.write("    SHAPE ABUTMENT ;\n")
        fid.write("    PORT\n")
        fid.write(f"      LAYER {port.get_layer()} ;\n")
        for rect in port.get_rects():
            fid.write(
                f"      RECT {rect[0]:.3f} {rect[1]:.3f} {rect[2]:.3f} {rect[3]:.3f} ;\n"
            )
        fid.write("    END\n")
        fid.write(f"  END {pin_name}\n")

    def write_obs(self, fid):
        """Writes out obstructions"""

        fid.write("  OBS\n")
        obs_data = self.get_memory().get_obstructions()
        for layer_name in sorted(obs_data.keys()):
            fid.write(f"    LAYER {layer_name} ;\n")
            for rect in obs_data[layer_name]:
                fid.write(
                    f"    RECT {rect[0]} {rect[1]} {rect[2]:.3f} {rect[3]:.3f} ;\n"
                )
        fid.write("  END\n")

    def write_pg_straps(self, fid):
        """Create power/ground straps"""

        pg_ports = self.get_memory().get_pg_ports()
        for port_name in sorted(pg_ports.keys()):
            port = pg_ports[port_name]
            self.write_pin(fid, port, False)

    def write_signal_bus(self, fid, name, lsb, msb):
        """Writes the individual pins for a signal bus"""

        name_format = f"{name}[%d]"
        for i in range(lsb, msb):
            port_name = name_format % i
            port = self.get_memory().get_port(port_name)
            self.write_pin(fid, port)

    def write_footer(self, fid, name):
        """LEF footer"""
        fid.write("END %s\n" % name)
        fid.write("\n")
        fid.write("END LIBRARY\n")

    def write_signals(self, fid, rw_port_group):
        """Writes rw signal bundle, comprised of dout, din, addr busses"""

        bits = self.get_memory().get_width()
        self.write_signal_bus(fid, rw_port_group.get_data_output_bus_name(), 0, bits)
        self.write_signal_bus(fid, rw_port_group.get_data_input_bus_name(), 0, bits)
        self.write_signal_bus(
            fid, rw_port_group.get_address_bus_name(), 0, self._memory.get_addr_width()
        )

    def write_signal_pins(self, fid):
        """LEF SIGNAL PINS"""

        mem = self.get_memory()
        y_step = mem.get_process_data().y_step
        for rw_port_group in mem.get_rw_port_groups():
            self.write_signals(fid, rw_port_group)
        for rw_port_group in mem.get_rw_port_groups():
            port = mem.get_port(rw_port_group.get_write_enable_name())
            self.write_pin(fid, port)
            port = mem.get_port(rw_port_group.get_clock_name())
            self.write_pin(fid, port)
        for bus_name, bus_data in mem.get_misc_busses().items():
            self.write_signal_bus(bus_name, bus_data["lsb"], bus_data["msb"])
        for port_name in mem.get_misc_ports():
            port = mem.get_port(port_name)
            self.write_pin(fid, port)
